# Data Model: Hybrid Cloud Integration

**Feature**: 004-hybrid-cloud-integration
**Date**: 2026-01-04
**Status**: Complete

## Overview

This document defines the data entities and their relationships for the Hybrid Cloud Integration feature. All data persists exclusively in the remote Neon PostgreSQL database via the production API at https://teot-phase2.vercel.app/.

---

## 1. Core Entities

### 1.1 Todo (Task)

Represents a user's todo item with full metadata.

**Attributes**:

| Field | Type | Required | Description | Constraints |
|-------|------|----------|-------------|-------------|
| `id` | string (UUID) | Yes | Unique identifier | Primary key, generated by backend |
| `title` | string | Yes | Task title | 1-200 characters, non-empty after trim |
| `description` | string | No | Detailed task description | 0-1000 characters |
| `completed` | boolean | Yes | Completion status | Default: false |
| `priority` | Priority | Yes | Task priority level | Enum: "low" \| "medium" \| "high" |
| `tags` | string[] | Yes | Categorization tags | Array of strings, can be empty |
| `dueDate` | Date | No | Task deadline with time | ISO 8601 datetime, nullable |
| `recurring` | RecurringConfig | No | Recurrence configuration | Complex object, nullable |
| `userId` | string (UUID) | Yes | Owner's user ID | Foreign key to User entity |
| `createdAt` | Date | Yes | Creation timestamp | ISO 8601 datetime, server-generated |
| `updatedAt` | Date | No | Last modification timestamp | ISO 8601 datetime, server-managed |

**Relationships**:
- **Many-to-One**: Todo → User (one user owns many todos)
- **Foreign Key**: `userId` references `User.id`
- **Data Isolation**: Backend enforces user-specific queries based on JWT token

**TypeScript Interface** (Frontend):
```typescript
interface Todo {
  id: string
  title: string
  description?: string
  completed: boolean
  priority: Priority
  tags: string[]
  dueDate?: Date
  recurring?: RecurringConfig
  userId: string
  createdAt: Date
  updatedAt?: Date
}

type Priority = 'low' | 'medium' | 'high'

interface RecurringConfig {
  enabled: boolean
  frequency: 'daily' | 'weekly' | 'monthly'
  interval: number // e.g., every 2 weeks = frequency: 'weekly', interval: 2
}
```

**Validation Rules**:
1. `title`: Must be non-empty after trimming whitespace
2. `title`: Length between 1-200 characters
3. `description`: Maximum 1000 characters
4. `priority`: Must be one of the enumerated values
5. `tags`: Each tag must be a non-empty string
6. `dueDate`: Must be a valid future date (or null)
7. `recurring.interval`: Must be >= 1
8. `userId`: Must match authenticated user's ID (enforced by backend)

**State Transitions**:
```
[Created: completed=false]
    ↓ (toggleTask)
[Completed: completed=true]
    ↓ (toggleTask or recurring reset)
[Created: completed=false]
```

**Recurring Task Logic**:
- When `recurring.enabled=true` and task is completed, backend automatically resets task after `interval * frequency` time passes
- New due date calculated: `oldDueDate + (interval * frequency_in_ms)`
- Task transitions back to `completed=false`

---

### 1.2 User

Represents an authenticated user account.

**Attributes**:

| Field | Type | Required | Description | Constraints |
|-------|------|----------|-------------|-------------|
| `id` | string (UUID) | Yes | Unique identifier | Primary key, generated by backend |
| `email` | string | Yes | User's email address | Unique, valid email format |
| `name` | string | No | Display name | Optional, 1-100 characters |
| `emailVerified` | boolean | Yes | Email verification status | Default: false |
| `image` | string (URL) | No | Profile picture URL | Valid URL or null |
| `createdAt` | Date | Yes | Account creation timestamp | ISO 8601 datetime |
| `updatedAt` | Date | No | Last profile update | ISO 8601 datetime |

**Relationships**:
- **One-to-Many**: User → Todo (one user owns many todos)
- **Cascade**: Deleting a user deletes all their todos (backend responsibility)

**TypeScript Interface** (Frontend):
```typescript
interface User {
  id: string
  email: string
  name?: string
  emailVerified: boolean
  image?: string
  createdAt: Date
  updatedAt?: Date
}
```

**Authentication Context**:
- User identity extracted from JWT token (claim: `user_id` or `sub`)
- Backend validates JWT signature using shared `BETTER_AUTH_SECRET`
- All API requests automatically scoped to authenticated user

---

### 1.3 JWT Token (Authentication)

Represents an authentication token issued by Better Auth.

**Claims** (Minimum Required):

| Claim | Type | Description |
|-------|------|-------------|
| `sub` or `user_id` | string (UUID) | User identifier |
| `exp` | number (Unix timestamp) | Expiration time |
| `iat` | number (Unix timestamp) | Issued at time |
| `email` | string | User's email (optional but recommended) |

**TypeScript Interface** (Frontend):
```typescript
interface JWTToken {
  token: string // Raw JWT string
  claims: {
    sub?: string // Standard "subject" claim
    user_id?: string // Alternative user ID claim
    exp: number // Expiration timestamp (Unix)
    iat: number // Issued at timestamp (Unix)
    email?: string // User email
  }
}
```

**Lifecycle**:
1. **Issuance**: Backend issues JWT after successful login
2. **Storage**: Better Auth stores in HTTP-only cookie (or localStorage)
3. **Transmission**: Frontend attaches as `Authorization: Bearer <token>` header
4. **Validation**: Backend verifies signature and expiration
5. **Expiration**: Frontend checks `exp` claim, refreshes or re-authenticates if expired
6. **Revocation**: Backend can invalidate tokens (out of scope for frontend)

**Security**:
- Signature Algorithm: HS256 (HMAC with SHA-256)
- Secret: Shared `BETTER_AUTH_SECRET` between frontend and backend
- Transmission: HTTPS only in production
- Expiration: Typically 1-24 hours (backend configuration)

---

## 2. API Request/Response Models

### 2.1 Standard Response Envelope

All API responses follow a consistent structure:

```typescript
interface ApiResponse<T> {
  data?: T
  error?: {
    code: string
    message: string
    details?: unknown
  }
}
```

**Success Response** (HTTP 200, 201):
```json
{
  "data": { /* entity or array of entities */ }
}
```

**Error Response** (HTTP 4xx, 5xx):
```json
{
  "error": {
    "code": "INVALID_TOKEN",
    "message": "JWT token is expired",
    "details": { "expiredAt": "2026-01-04T12:00:00Z" }
  }
}
```

---

### 2.2 Paginated Response

For list endpoints that support pagination:

```typescript
interface PaginatedResponse<T> {
  data: T[]
  pagination: {
    total: number
    page: number
    pageSize: number
    totalPages: number
  }
}
```

**Example** (GET /api/todos?page=1&pageSize=20):
```json
{
  "data": [
    { /* Todo entity */ },
    { /* Todo entity */ }
  ],
  "pagination": {
    "total": 150,
    "page": 1,
    "pageSize": 20,
    "totalPages": 8
  }
}
```

**Note**: Pagination is optional for this phase. If not implemented by backend, all todos returned in single response.

---

### 2.3 Create/Update Request Bodies

**Create Todo Request**:
```typescript
interface CreateTodoRequest {
  title: string // Required, 1-200 chars
  description?: string // Optional, 0-1000 chars
  priority?: Priority // Optional, default: "medium"
  tags?: string[] // Optional, default: []
  dueDate?: string // Optional, ISO 8601 string
  recurring?: RecurringConfig // Optional
}
```

**Update Todo Request** (Partial Update):
```typescript
interface UpdateTodoRequest {
  title?: string
  description?: string
  completed?: boolean
  priority?: Priority
  tags?: string[]
  dueDate?: string | null // null to clear due date
  recurring?: RecurringConfig | null // null to disable recurring
}
```

**Note**: All date fields sent as ISO 8601 strings, converted to Date objects on frontend.

---

## 3. Data Flow Diagrams

### 3.1 Create Task Flow

```
[User] → [TaskForm Component] → [useTodos Hook]
                                      ↓
                              [API Client: POST /api/todos]
                                      ↓ (Authorization: Bearer <JWT>)
                              [Backend API]
                                      ↓
                              [Neon PostgreSQL]
                                      ↓ (Task saved with userId)
                              [Backend API] ← (201 Created + Task entity)
                                      ↓
                              [API Client] ← (Parse response)
                                      ↓
                              [useTodos Hook] ← (Update state)
                                      ↓
                              [TaskList Component] ← (Re-render with new task)
```

### 3.2 Authentication Flow

```
[User] → [Login Form] → [Better Auth]
                              ↓ (POST /api/auth/login)
                        [Backend API]
                              ↓ (Validate credentials)
                        [Issue JWT Token]
                              ↓
                        [Better Auth] ← (Store token in cookie)
                              ↓
                        [authClient.useSession()] ← (Expose session state)
                              ↓
                        [API Client] ← (Read JWT from session)
                              ↓
                        [All API Requests] ← (Attach Authorization header)
```

### 3.3 Error Recovery Flow (401 Unauthorized)

```
[API Client: GET /api/todos]
      ↓ (Authorization: Bearer <expired_token>)
[Backend API] ← (Validate JWT)
      ↓ (401 Unauthorized)
[API Client] ← (Detect 401 status)
      ↓
[Check if token refresh possible]
      ↓ (No) → [authClient.signOut()] → [Redirect to /login]
      ↓ (Yes) → [Attempt token refresh] → [Retry original request]
```

---

## 4. Data Transformation Rules

### 4.1 Date Handling

**Backend → Frontend**:
- Backend sends: `"2026-01-04T14:30:00Z"` (ISO 8601 string)
- Frontend receives: String
- Frontend converts: `new Date("2026-01-04T14:30:00Z")` → Date object
- TypeScript type: `Date`

**Frontend → Backend**:
- Frontend has: `Date` object
- Frontend converts: `date.toISOString()` → `"2026-01-04T14:30:00Z"`
- Backend receives: String
- Backend stores: Timestamp in database

**Edge Cases**:
- Null dates: `null` remains `null` (no conversion needed)
- Invalid dates: Caught by validation, error returned to user

### 4.2 Boolean Handling

**Consistency**:
- Frontend: `true` / `false` (boolean)
- Backend: `true` / `false` (boolean) or `1` / `0` (integer in database)
- API: Always use JSON boolean `true` / `false`

### 4.3 Enum Handling

**Priority Enum**:
- Frontend: `"low" | "medium" | "high"` (TypeScript literal type)
- Backend: Database enum or varchar with constraint
- Validation: Both frontend and backend validate against allowed values

---

## 5. Data Validation Summary

### Frontend Validation (Client-Side)

**Purpose**: Provide instant feedback to users, reduce invalid API calls

**Rules**:
1. Title: Non-empty, 1-200 characters
2. Description: Max 1000 characters
3. Priority: Must be "low", "medium", or "high"
4. Due Date: Must be valid date in future (optional)
5. Tags: Non-empty strings
6. Recurring Interval: Integer >= 1

**Implementation**: Form validation before submission

### Backend Validation (Server-Side)

**Purpose**: Enforce data integrity, prevent malicious input

**Rules**: Same as frontend + additional security checks
1. User ID: Must match authenticated JWT token
2. SQL Injection: Parameterized queries
3. XSS: Input sanitization (if rendering user content)
4. Rate Limiting: Prevent abuse (backend responsibility)

**Implementation**: Request validation middleware + database constraints

---

## 6. Migration Considerations

### From Mock Data to API

**Current State** (Mock):
- Data stored in `localStorage` (key: `"taskhive-todos"`)
- Todos stored as JSON string
- No server-side validation
- No user isolation (all users see all todos on same device)

**Target State** (API):
- Data stored in remote Neon PostgreSQL database
- Todos accessed via REST API
- Server-side validation enforced
- User isolation via JWT authentication

**Migration Steps**:
1. **No Data Migration**: Existing localStorage data is abandoned (out of scope)
2. **Clean Start**: Users create new tasks in remote database
3. **Remove localStorage**: Delete all localStorage calls from `use-mock-todos.ts`
4. **User Onboarding**: Inform users that local data won't be migrated (if applicable)

**Rationale**: Local data is ephemeral and test data; migration is not required.

---

## 7. Entity Relationships Diagram

```
┌─────────────────────┐
│      User           │
│─────────────────────│
│ id (PK)             │ 1
│ email               │ │
│ name                │ │ owns
│ emailVerified       │ │
│ image               │ │
│ createdAt           │ │
│ updatedAt           │ │
└─────────────────────┘ │
                        │
                        │ 1:N
                        │
                        │
┌─────────────────────┐ N
│      Todo           │
│─────────────────────│
│ id (PK)             │
│ userId (FK) ────────┘
│ title               │
│ description         │
│ completed           │
│ priority            │
│ tags                │
│ dueDate             │
│ recurring           │
│ createdAt           │
│ updatedAt           │
└─────────────────────┘
```

**Notes**:
- User-Todo relationship is **One-to-Many** (1:N)
- Foreign key `userId` enforces referential integrity
- Cascade delete: If user deleted, all their todos are deleted (backend rule)

---

## 8. Summary

**Key Points**:
1. **Two Core Entities**: Todo and User
2. **Authentication**: JWT tokens carry user identity
3. **Data Isolation**: Backend enforces user-specific queries
4. **No Local Storage**: All data persists remotely
5. **Type Safety**: TypeScript interfaces match backend schema
6. **Validation**: Both client and server validate input
7. **Date Handling**: ISO 8601 strings over the wire, Date objects in memory
8. **Error Handling**: Standardized response envelope

**Dependencies**:
- Backend API must provide documented endpoints (see `contracts/` directory)
- Backend must enforce user isolation based on JWT
- Database schema must support all required fields and relationships

**Next Steps**:
1. ✅ Data model complete
2. → Generate API contracts in `contracts/` directory (OpenAPI/REST spec)
3. → Write quickstart guide for developers
4. → Update agent context
5. → Complete implementation plan

---

**Data Model Defined By**: Claude (Sonnet 4.5)
**Validation**: All entities align with feature specification and research decisions
